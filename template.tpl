___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "type": "TAG",
  "id": "cvt_temp_public_id",
  "version": 1,
  "securityGroups": [],
  "displayName": "Logger",
  "brand": {
    "id": "brand_dummy",
    "displayName": "",
    "thumbnail": "data:image/png;base64,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\u003d\u003d"
  },
  "description": "Log to a console or BigQuery a JSON string with desired info. Useful for debugging, especially for POST requests.",
  "containerContexts": [
    "SERVER"
  ]
}


___TEMPLATE_PARAMETERS___

[
  {
    "type": "SELECT",
    "name": "logDestination",
    "displayName": "Logs Destination",
    "selectItems": [
      {
        "value": "console",
        "displayValue": "Console"
      },
      {
        "value": "bigQuery",
        "displayValue": "BigQuery"
      }
    ],
    "simpleValueType": true,
    "help": "Choose the destination of your logs:\n\u003cbr\u003e\n\u003cul\u003e\n\u003cli\u003eConsole\u003c/li\u003e\n\u003cli\u003eBigQuery table\u003c/li\u003e\n\u003c/ul\u003e",
    "defaultValue": "console",
    "alwaysInSummary": true
  },
  {
    "type": "RADIO",
    "name": "logType",
    "radioItems": [
      {
        "value": "debug",
        "displayValue": "Log during debug and preview"
      },
      {
        "value": "always",
        "displayValue": "Always log"
      }
    ],
    "simpleValueType": true,
    "defaultValue": "debug",
    "displayName": "Logs Settings",
    "valueValidators": [
      {
        "type": "NON_EMPTY"
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "logsBiqQueryConfigGroup",
    "displayName": "",
    "groupStyle": "NO_ZIPPY",
    "subParams": [
      {
        "type": "TEXT",
        "name": "logBigQueryProjectId",
        "displayName": "BigQuery Project ID",
        "simpleValueType": true,
        "help": "Optional.  \u003cbr\u003e\u003cbr\u003e  If omitted, it will be retrieved from the environment variable \u003cI\u003eGOOGLE_CLOUD_PROJECT\u003c/i\u003e where the server container is running. If the server container is running on Google Cloud, \u003cI\u003eGOOGLE_CLOUD_PROJECT\u003c/i\u003e will already be set to the Google Cloud project\u0027s ID."
      },
      {
        "type": "TEXT",
        "name": "logBigQueryDatasetId",
        "displayName": "BigQuery Dataset ID",
        "simpleValueType": true,
        "valueValidators": [
          {
            "type": "NON_EMPTY"
          }
        ]
      },
      {
        "type": "TEXT",
        "name": "logBigQueryTableId",
        "displayName": "BigQuery Table ID",
        "simpleValueType": true,
        "valueValidators": [
          {
            "type": "NON_EMPTY"
          }
        ]
      }
    ],
    "enablingConditions": [
      {
        "paramName": "logDestination",
        "paramValue": "bigQuery",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "TEXT",
    "name": "eventName",
    "displayName": "Event Name",
    "simpleValueType": true,
    "help": "It helps to find your event in logs later."
  },
  {
    "type": "CHECKBOX",
    "name": "eventData",
    "checkboxText": "Log all Event Data",
    "simpleValueType": true
  },
  {
    "type": "CHECKBOX",
    "name": "requestUrl",
    "checkboxText": "Log Request Url",
    "simpleValueType": true
  },
  {
    "type": "CHECKBOX",
    "name": "requestBody",
    "checkboxText": "Log Request Body",
    "simpleValueType": true
  },
  {
    "type": "CHECKBOX",
    "name": "requestBodyJson",
    "checkboxText": "Parse Request Body as JSON",
    "simpleValueType": true,
    "enablingConditions": [
      {
        "paramName": "requestBody",
        "paramValue": true,
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "customGroup",
    "displayName": "Custom Data",
    "groupStyle": "ZIPPY_CLOSED",
    "subParams": [
      {
        "type": "SIMPLE_TABLE",
        "name": "custom",
        "simpleTableColumns": [
          {
            "defaultValue": "",
            "displayName": "Name",
            "name": "name",
            "type": "TEXT"
          },
          {
            "defaultValue": "",
            "displayName": "Value",
            "name": "value",
            "type": "TEXT"
          }
        ]
      }
    ]
  }
]


___SANDBOXED_JS_FOR_SERVER___

const BigQuery = require('BigQuery');
const JSON = require('JSON');
const getAllEventData = require('getAllEventData');
const makeTableMap = require('makeTableMap');
const getRequestHeader = require('getRequestHeader');
const getRequestBody = require('getRequestBody');
const getRequestPath = require('getRequestPath');
const getRequestQueryString = require('getRequestQueryString');
const logToConsole = require('logToConsole');
const getContainerVersion = require('getContainerVersion');
const getTimestampMillis = require('getTimestampMillis');
const getType = require('getType');

const isLoggingEnabled = determinateIsLoggingEnabled();
const traceId = getRequestHeader('trace-id');

/**********************************************************************************************/

// To accomodate a breaking change.
// The previous version before it only had 'console' as a possible destination.
const logDestination = data.logDestination || 'console';

const logDestinationsHandlers = {
  console: log,
  bigQuery: logToBigQuery
};

// Key mappings for each log destination
const keyMappings = {
  console: {
    Name: 'Name',
    Type: 'Type',
    TraceId: 'TraceId',
    EventName: 'EventName',
    CustomData: 'CustomData',
    EventData: 'EventData',
    RequestUrl: 'RequestUrl',
    RequestBody: 'RequestBody'
  },
  bigQuery: {
    Name: 'tag_name',
    Type: 'type',
    TraceId: 'trace_id',
    EventName: 'event_name',
    CustomData: 'custom_data',
    EventData: 'event_data',
    RequestUrl: 'request_url',
    RequestBody: 'request_body'
  }
};

if (isLoggingEnabled) {
  const rawData = {
    Name: 'Logger',
    Type: 'Message',
    TraceId: traceId,
    EventName: data.eventName ? data.eventName : 'Logger'
  };

  if (data.custom && data.custom.length > 0) {
    rawData.CustomData = makeTableMap(data.custom, 'name', 'value');
  }

  if (data.eventData) {
    rawData.EventData = getAllEventData();
  }

  if (data.requestUrl) {
    rawData.RequestUrl = getRequestPath();

    const queryString = getRequestQueryString();
    if (queryString !== '') {
      rawData.RequestUrl += '?' + queryString;
    }
  }

  if (data.requestBody) {
    const body = getRequestBody();
    rawData.RequestBody =
      data.requestBodyJson && body ? JSON.parse(body) : body;
  }

  // Map keys based on the log destination
  const dataToLog = {};
  const mapping = keyMappings[logDestination];
  for (const key in rawData) {
    const mappedKey = mapping[key] || key; // Fallback to original key if no mapping exists
    dataToLog[mappedKey] = rawData[key];
  }

  const handler = logDestinationsHandlers[logDestination];
  if (handler) handler(dataToLog);
}

data.gtmOnSuccess();

/**********************************************************************************************/

function determinateIsLoggingEnabled() {
  const containerVersion = getContainerVersion();
  const isDebug = containerVersion.debugMode;

  if (!data.logType) {
    return isDebug;
  }

  if (data.logType === 'debug') {
    return isDebug;
  }

  return data.logType === 'always';
}

function log(dataToLog) {
  logToConsole(JSON.stringify(dataToLog));
}

function logToBigQuery(dataToLog) {
  const connectionInfo = {
    projectId: data.logBigQueryProjectId,
    datasetId: data.logBigQueryDatasetId,
    tableId: data.logBigQueryTableId
  };

  // timestamp is required.
  dataToLog.timestamp = getTimestampMillis();

  // Columns with type JSON need to be stringified.
  ['custom_data', 'event_data', 'request_body'].forEach(
    (p) => (dataToLog[p] = JSON.stringify(dataToLog[p]))
  );

  // assertApi doesn't work for 'BigQuery.insert()'. It's needed to convert BigQuery into a function when testing.
  // Ref: https://gtm-gear.com/posts/gtm-templates-testing/
  const bigquery =
    getType(BigQuery) === 'function'
      ? BigQuery() /* Only during Unit Tests */
      : BigQuery;
  bigquery.insert(connectionInfo, [dataToLog], { ignoreUnknownValues: true });
}


___SERVER_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "read_request",
        "versionId": "1"
      },
      "param": [
        {
          "key": "requestAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        },
        {
          "key": "headerAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        },
        {
          "key": "queryParameterAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "all"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_container_data",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_event_data",
        "versionId": "1"
      },
      "param": [
        {
          "key": "eventDataAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "access_bigquery",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedTables",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "projectId"
                  },
                  {
                    "type": 1,
                    "string": "datasetId"
                  },
                  {
                    "type": 1,
                    "string": "tableId"
                  },
                  {
                    "type": 1,
                    "string": "operation"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "write"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: Should log, if this 'Log during debug and preview' option is selected AND
    is on preview mode
  code: "mockData.logType = 'debug';\n\n// assertApi doesn't work for 'BigQuery.insert()'.\n\
    // Ref: https://gtm-gear.com/posts/gtm-templates-testing/\nmock('BigQuery', ()\
    \ => {\n  return { \n    insert: (connectionInfo, rows, options) => { \n     \
    \ assertThat(connectionInfo).isDefined(); // Simple check if the code reached\
    \ here.\n      return Promise.create((resolve, reject) => {\n        resolve();\n\
    \      });\n    }\n  };\n});\n\n[\n  { expectedDebugMode: true, logDestination:\
    \ 'console' },\n  { expectedDebugMode: true, logDestination: 'bigQuery' },\n].forEach(scenario\
    \ => {\n  mockData.logDestination = scenario.logDestination;\n  mock('getContainerVersion',\
    \ () => {\n    return {\n      debugMode: scenario.expectedDebugMode\n    };\n\
    \  }); \n  runCode(mockData);\n  if (scenario.logDestination === 'console') assertApi('logToConsole').wasCalled();\n\
    });"
- name: Should NOT log, if this 'Log during debug and preview' option is selected
    AND is NOT on preview mode
  code: "mockData.logType = 'debug';\n\n// assertApi doesn't work for 'BigQuery.insert()'.\n\
    // Ref: https://gtm-gear.com/posts/gtm-templates-testing/\nmock('BigQuery', ()\
    \ => {\n  return { \n    insert: (connectionInfo, rows, options) => { \n     \
    \ fail('BigQuery.insert should not have been called.');\n      return Promise.create((resolve,\
    \ reject) => {\n        resolve();\n      });\n    }\n  };\n});\n\n[\n  { expectedDebugMode:\
    \ false, logDestination: 'console' },\n  { expectedDebugMode: false, logDestination:\
    \ 'bigQuery' }\n].forEach(scenario => {\n  mockData.logDestination = scenario.logDestination;\n\
    \  mock('getContainerVersion', () => {\n    return {\n      debugMode: scenario.expectedDebugMode\n\
    \    };\n  }); \n  runCode(mockData);\n  if (scenario.logDestination === 'console')\
    \ assertApi('logToConsole').wasNotCalled();\n});"
- name: Should log always, if this option is selected
  code: "mockData.logType = 'always';\n\n// assertApi doesn't work for 'BigQuery.insert()'.\n\
    // Ref: https://gtm-gear.com/posts/gtm-templates-testing/\nmock('BigQuery', ()\
    \ => {\n  return { \n    insert: (connectionInfo, rows, options) => { \n     \
    \ assertThat(connectionInfo).isDefined(); // Simple check if the code reached\
    \ here.\n      return Promise.create((resolve, reject) => {\n        resolve();\n\
    \      });\n    }\n  };\n});\n\n[\n  { expectedDebugMode: true, logDestination:\
    \ 'console' },\n  { expectedDebugMode: true, logDestination: 'bigQuery' },\n \
    \ { expectedDebugMode: false, logDestination: 'console' },\n  { expectedDebugMode:\
    \ false, logDestination: 'bigQuery' },\n].forEach(scenario => {\n  mockData.logDestination\
    \ = scenario.logDestination;\n  mock('getContainerVersion', () => {\n    return\
    \ {\n      debugMode: scenario.expectedDebugMode\n    };\n  }); \n  runCode(mockData);\n\
    \  if (scenario.logDestination === 'console') assertApi('logToConsole').wasCalled();\n\
    });"
- name: logToConsole logs everything correctly
  code: "const makeTableMap = require('makeTableMap'); \n\nconst customData = [{ name:\
    \ expectedValue, value: expectedValue }];\nconst expectedCustomData = makeTableMap(customData,\
    \ 'name', 'value');\n\nconst expectedEventData = {\n  event_name: expectedValue,\n\
    \  param: expectedValue,\n  page_location: expectedValue\n};\n\nconst expectedRequestBody\
    \ = JSON.stringify(expectedEventData);\n\nmockData.logType = 'always';\nmockData.logDestination\
    \ = 'console';\nmockData.eventData = true;\nmockData.requestUrl = true;\nmockData.requestBody\
    \ = true;\nmockData.custom = customData;\nmockData.eventName = expectedValue;\n\
    \nmock('getRequestHeader', (header) => {\n  if (header === 'trace-id') return\
    \ expectedValue;\n});\n\nmock('getRequestPath', () => {\n  return expectedValue;\n\
    });\n\nmock('getRequestQueryString', () => {\n  return expectedValue;\n});\n\n\
    mock('getRequestBody', () => {\n  return expectedRequestBody;\n});\n\nmock('getAllEventData',\
    \ () => {\n  return expectedEventData;\n});\n\nrunCode(mockData);\n\nassertApi('logToConsole').wasCalledWith(\n\
    \  JSON.stringify({\n    Name: 'Logger',\n    Type: 'Message',\n    TraceId: expectedValue,\n\
    \    EventName: expectedValue,\n    CustomData: expectedCustomData,\n    EventData:\
    \ expectedEventData,\n    RequestUrl: expectedValue + '?' + expectedValue,\n \
    \   RequestBody: expectedRequestBody\n  })\n);\n"
- name: BigQuery_insert logs everything correctly
  code: "const makeTableMap = require('makeTableMap'); \n\nconst customData = [{ name:\
    \ expectedValue, value: expectedValue }];\nlet expectedCustomData = makeTableMap(customData,\
    \ 'name', 'value');\n\nlet expectedEventData = {\n  event_name: expectedValue,\n\
    \  param: expectedValue,\n  page_location: expectedValue\n};\n\nlet expectedRequestBody\
    \ = JSON.stringify(expectedEventData);\n\nconst expectedConnectionInfo = {\n \
    \ projectId: mockData.logBigQueryProjectId,\n  datasetId: mockData.logBigQueryDatasetId,\n\
    \  tableId: mockData.logBigQueryTableId\n};\n\nmockData.logType = 'always';\n\
    mockData.logDestination = 'bigQuery';\nmockData.eventData = true;\nmockData.requestUrl\
    \ = true;\nmockData.requestBody = true;\nmockData.custom = customData;\nmockData.eventName\
    \ = expectedValue;\n\nmock('getRequestHeader', (header) => {\n  if (header ===\
    \ 'trace-id') return expectedValue;\n});\n\nmock('getRequestPath', () => {\n \
    \ return expectedValue;\n});\n\nmock('getRequestQueryString', () => {\n  return\
    \ expectedValue;\n});\n\nmock('getRequestBody', () => {\n  return expectedRequestBody;\n\
    });\n\nmock('getAllEventData', () => {\n  return expectedEventData;\n});\n\nmock('getTimestampMillis',\
    \ () => {\n  return expectedValue;\n});\n\n// assertApi doesn't work for 'BigQuery.insert()'.\n\
    // Ref: https://gtm-gear.com/posts/gtm-templates-testing/\nmock('BigQuery', ()\
    \ => {\n  return { \n    insert: (connectionInfo, rows, options) => { \n     \
    \ assertThat(connectionInfo).isEqualTo(expectedConnectionInfo);\n      assertThat(options).isEqualTo({\
    \ ignoreUnknownValues: true });\n      assertThat(rows).isEqualTo([{\n       \
    \ tag_name: 'Logger',\n        type: 'Message',\n        trace_id: expectedValue,\n\
    \        event_name: expectedValue,\n        custom_data: stringifyJsonToBigQuery(expectedCustomData),\n\
    \        event_data: stringifyJsonToBigQuery(expectedEventData),\n        request_url:\
    \ expectedValue + '?' + expectedValue,\n        request_body: stringifyJsonToBigQuery(expectedRequestBody),\n\
    \        timestamp: expectedValue\n      }]);\n\n      return Promise.create((resolve,\
    \ reject) => {\n        resolve();\n      });\n    }\n  };\n});\n\nrunCode(mockData);\n"
setup: |-
  const JSON = require('JSON');
  const Promise = require('Promise');

  const expectedValue = 'test';

  const mockData = {
    logBigQueryProjectId: expectedValue,
    logBigQueryDatasetId: expectedValue,
    logBigQueryTableId: expectedValue
  };

  // Must be used whenever the column type in BQ is JSON.
  function stringifyJsonToBigQuery(jsonObj) {
    const jsonString = JSON.stringify(jsonObj);
    return jsonString ? jsonString.split('"').join('\"') : undefined;
  }


___NOTES___

Created on 18/04/2022, 09:51:02


